<!DOCTYPE html>
<html>
<head>
    <style>
        .main-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            /* margin: 0 auto; */
            /* margin-left: 600px; */
            position: relative;
            width: fit-content;
            left: 30%;
        }

        /* Container wrapper to maintain relative positioning */
        .left-container {
            position: relative;
            /* max-width: 200px; */
            margin: 0 auto;
            /* justify-content: center; */
        }

        .right-container {
            /* position: relative; */
            /* max-width: 200px; */
            margin: 0 auto;
            justify-content: center;
        }

        /************************
        * time blocks
        */
        .grid-container {
            display: grid;
            grid-template-columns: 60px repeat(6, 1fr);
            gap: 1px;
            background-color: #eee;
            /* padding: 10px; */
            max-width: 200px;
            margin: 0 auto;
        }

        .header-cell {
            background-color: #f8f9fa;
            padding: 8px;
            /* width: 30px;  */
            text-align: center;
            font-weight: bold;
        }

        .time-cell {
            background-color: #f8f9fa;
            padding: 8px;
            text-align: right;
        }

        .grid-cell {
            background-color: white;
            min-height: 24px;
            border: 1px solid #ddd;
            padding: 4px;
            cursor: pointer;
            position: relative;
            /* overflow: hidden; */
            /* overflow: visible;  */
            white-space: nowrap; 
            z-index: 1; 
        }

        .grid-cell:hover {
            border-color: #aaa;
        }


        /************************
        * time blocks
        */
        .time-summary {
            position: absolute;
            /* top: 100%; */
            right: -110%;

            margin-top: 45px; /* Align with grid top */
            min-width: 120px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            /* position: sticky; */
            /* left: 100%; */
            /* height: fit-content; */
        }

        .color-summary-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ddd;
        }

        .time-value {
            margin-left: auto;
        }

        /************************
        * color picker
        */
        .color-picker {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 20px;
            max-width: 200px;
            margin: 0 auto;
            align-items: center;
            position: relative;
        }

        .add-color-btn {
            width: 32px;
            height: 32px;
            border: 2px dashed #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: white;
        }

        .add-color-btn:hover {
            border-color: #666;
        }

        .color-picker-popup {
            position: absolute;
            top: 100%;
            right: 20px;
            min-width: 200px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .color-picker-popup.show {
            display: block;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .color-input-group input {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-option:hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }

        #colorInput {
            margin-bottom: 10px;
        }

        .editing-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #4299e1;
            padding: 4px;
            resize: none;
            font-family: inherit;
            font-size: inherit;
            box-sizing: border-box;
            background-color: transparent; /* time-block을 클릭하자마자 색칠되게 한다 */
        }


        /************************
        * save & load 
        */

        .floating-controls {
            position: relative;
            top: 90%;
            /* bottom: 0%; */
            /* right: -100%; */
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            fill: #666;
        }

        #loadInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="main-layout">

        <div class="left-container">
            <div class="time-summary" id="timeSummary">
                <!-- Summary will be populated by JavaScript -->
            </div>

            <div class="floating-controls">
                <button id="saveButton" class="control-btn" title="Save Timeline">
                    <svg viewBox="0 0 24 24">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                </button>
                <button id="loadButton" class="control-btn" title="Load Timeline">
                    <svg viewBox="0 0 24 24">
                        <path d="M5 15h14l-7-7-7 7z"/>
                    </svg>
                </button>
                <input type="file" id="loadInput" accept=".json">
            </div>
        </div>

        <div class="right-container">
            <div class="grid-container" id="timeGrid">
                <!-- Grid will be populated by JavaScript -->
            </div>
            
            <div class="color-picker" id="colorPicker">
                <!-- Color options will be populated by JavaScript -->
                <!-- <div class="color-option" style="background-color: #a5d8ff"></div> -->

                <button class="add-color-btn" id="addColorBtn">+</button>
                <div class="color-picker-popup" id="colorPickerPopup">
                    <div class="color-input-group">
                        <input type="color" id="colorInput" value="#a5d8ff">
                        <input type="text" id="colorLabel" placeholder="Enter color label">
                    </div>
                    <button class="save-btn" id="saveColorBtn">Add Color</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        let selectedColor = 'rgb(255, 255, 255)'; //default cell-background-color is white

        const blockData = {};
        let dragStartColors = new Map(); // To store original colors when drag starts
        let selectedCells = new Set();

        let savedColors = [
            { color: '#ffffff', label: 'Rest' },
            { color: '#000000', label: 'Sleep' },
            { color: '#44f275', label: 'Learn' },
            { color: '#fcff5e', label: 'Fun' },
            { color: '#38adf5', label: 'Prep' },
            { color: '#ed2a02', label: '운동' },
        ];

        //drag multiple time-blocks
        let isDragging = false;
        let startCell = null;

        //style for previous color inside time-block
        const previousColorStyle = `
            .grid-cell.color-changed {
                border: 1.5px solid #fa9d1b;
                padding-left: 16px;
                position: relative;
            }

            .grid-cell.color-changed::before {
                content: '';
                position: absolute;
                top: -3px;
                left: -3px;
                border-style: solid;
                border-width: 12px 12px 0 0;
                border-right-color: transparent;
                border-top-color: var(--previous-color);
            }
            `;

        // Add the styles to the document
        const styleSheet = document.createElement("style");
        styleSheet.textContent = previousColorStyle;
        document.head.appendChild(styleSheet);

        // variable for editting cell
        let currentlyEditingCell = null;


        function initializeGrid() {
            const grid = document.getElementById('timeGrid');

            // Add header row
            grid.appendChild(createCell('Hour', 'header-cell'));
            for (let i = 1; i <= 6; i++) {
                grid.appendChild(createCell(`${i}0m`, 'header-cell'));
            }

            // Create time blocks
            for (let hour = 0; hour < 24; hour++) {
                const displayHour = (hour + 6) % 24;
                grid.appendChild(createCell(
                    `${String(displayHour).padStart(2, '0')}:00`,
                    'time-cell'
                ));

                for (let block = 0; block < 6; block++) {
                    const cell = createCell('', 'grid-cell');
                    cell.dataset.hour = hour;
                    cell.dataset.block = block;

                    // Add mouse events for drag selection
                    cell.addEventListener('mousedown', (e) => {
                        isDragging = false;
                        startCell = cell;
                        selectedCells.clear();

                        storeCurrentColors();

                        // Add initial cell to selected set
                        const cellKey = `${hour}-${block}`;
                        selectedCells.add(cellKey);
                    });

                    cell.addEventListener('mousemove', (e) => {
                        if (e.buttons === 1 && startCell) {
                            const currentHour = cell.dataset.hour;
                            const currentBlock = cell.dataset.block;
                            const cellKey = `${currentHour}-${currentBlock}`;
                            
                            // Add cell to selected set
                            selectedCells.add(cellKey);
                            
                            // If more than one cell is selected, it's a drag
                            if (selectedCells.size > 1) {
                                isDragging = true;
                                handleDragPaint(startCell, cell);
                            }
                        }
                    });

                    // Handle single cell click
                    cell.addEventListener('mouseup', (e) => {
                        if (!isDragging && selectedCells.size === 1) {
                            handleCellClick(e);
                        }
                        selectedCells.clear();
                    });

                    grid.appendChild(cell);
                }
            }

            // Add mouseup event to document to handle drag end
            document.addEventListener('mouseup', () => {
                isDragging = false;
                startCell = null;
                dragStartColors.clear(); 
                selectedCells.clear();
            });

            // Prevent text selection while dragging
            grid.addEventListener('selectstart', (e) => {
                if (isDragging) {
                    e.preventDefault();
                }
            });
        }

        function createCell(text, className) {
            const cell = document.createElement('div');
            cell.className = className;
            cell.textContent = text;
            if (className === 'grid-cell') {
                // Explicitly set initial background color
                cell.style.backgroundColor = 'rgb(255, 255, 255)';  // set default background color to white
            }
            return cell;
        }

        function handleCellClick(event) {
            const cell = event.target.classList.contains('grid-cell') ? 
                event.target : 
                event.target.closest('.grid-cell');
            
            if (!cell) return;

            // If we're clicking on a different cell, save the previous cell's content
            if (currentlyEditingCell && currentlyEditingCell !== cell) {
                const textarea = currentlyEditingCell.querySelector('.editing-textarea');
                if (textarea) {
                    const prevHour = currentlyEditingCell.dataset.hour;
                    const prevBlock = currentlyEditingCell.dataset.block;
                    const prevKey = `${prevHour}-${prevBlock}`;
                    saveBlock(prevKey, textarea.value, currentlyEditingCell);
                    textarea.remove();
                }
            }

            currentlyEditingCell = cell;

            const hour = cell.dataset.hour;
            const block = cell.dataset.block;
            const blockKey = `${hour}-${block}`;


            // Get the original color from our stored Map
            const originalColor = dragStartColors.get(blockKey) || 'rgb(255, 255, 255)';
            const newColor = normalizeColor(selectedColor);

            if (originalColor && normalizeColor(originalColor) !== newColor) {
                cell.classList.add('color-changed');
                cell.style.borderColor = '#fa9d1b';
                cell.style.setProperty('--previous-color', originalColor);
            } else {
                cell.classList.remove('color-changed');
                cell.style.borderColor = '';
                cell.style.removeProperty('border-top-color');
                cell.style.removeProperty('--previous-color');
            }

            // Apply new color
            cell.style.backgroundColor = selectedColor;

            // Save current state to blockData immediately
            blockData[blockKey] = {
                text: blockData[blockKey]?.text || '',
                color: selectedColor,
                previousColor: originalColor || null
            };

            // Clear the cell's text content before adding textarea
            const existingText = cell.textContent;  // Store existing text
            cell.textContent = '';  // Clear the cell

            // Remove any existing textarea
            const existingTextarea = document.querySelector('.editing-textarea');
            if (existingTextarea) {
                existingTextarea.remove();
            }

            // Create and add new textarea
            const textarea = document.createElement('textarea');
            textarea.className = 'editing-textarea';
            textarea.value = existingText || blockData[blockKey]?.text || '';
            
            // 배경색상이 검정색이면 글자색을 흰색으로 변경 
            if (rgbToHex(selectedColor) === '#000000') {
                textarea.style.color = 'white'; //이게 텍스트 컬러 바꾸는게 아니라 triangle 컬러 바꾸더라 
            } else {
                textarea.style.color = 'black';
            }
            
            // textarea.style.backgroundColor = 'transparent';
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveBlock(blockKey, textarea.value, cell);
                    textarea.remove();
                    currentlyEditingCell = null;
                }
            });

            cell.appendChild(textarea);
            textarea.focus();

            updateTimeSummary();
        }


        function saveBlock(blockKey, text, cell) {
            // Get the current previous color if it exists
            const previousColor = dragStartColors.get(blockKey);
        
            blockData[blockKey] = {
                text: text,
                color: selectedColor,
                previousColor: previousColor || null  
            };

            // Update cell display
            cell.textContent = text;
            cell.style.backgroundColor = selectedColor;

            // Set text color to white if background is black
            if (rgbToHex(selectedColor) === '#000000') {
                cell.style.color = 'white';
            } else {
                cell.style.color = 'black';  // Reset to default for other colors
            }
        }

        // Initialize color picker
        function initializeColorPicker() {
            const colorPicker = document.getElementById('colorPicker');
            const addColorBtn = document.getElementById('addColorBtn');
            const popup = document.getElementById('colorPickerPopup');
            const colorInput = document.getElementById('colorInput');
            const colorLabel = document.getElementById('colorLabel');
            const saveColorBtn = document.getElementById('saveColorBtn');


            // Clear existing color options except the add button and popup
            const children = Array.from(colorPicker.children);
            children.forEach(child => {
                if (child !== addColorBtn && child !== popup) {
                    child.remove();
                }
            });

            // Add color options
            savedColors.forEach(({color, label}) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.dataset.label = label; // This enables the hover tooltip
                colorOption.addEventListener('click', () => {
                    selectedColor = color;
                });
                colorPicker.insertBefore(colorOption, addColorBtn);
            });

            // Add color button handler
            addColorBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                popup.classList.toggle('show');
                colorLabel.value = ''; // Reset label input
            });

            // Save color button handler
            saveColorBtn.addEventListener('click', () => {
                const newColor = colorInput.value;
                const newLabel = colorLabel.value.trim() || newColor; // Use color code if no label provided
                
                if (!savedColors.some(c => c.color === newColor)) {
                    savedColors.push({
                        color: newColor,
                        label: newLabel
                    });
                    initializeColorPicker();  // Refresh color picker
                }
                popup.classList.remove('show');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!popup.contains(e.target) && e.target !== addColorBtn) {
                    popup.classList.remove('show');
                }
            });
        }


        // Add this function to handle drag painting
        function handleDragPaint(startCell, currentCell) {
            // Get row and column indices
            const startHour = parseInt(startCell.dataset.hour);
            const startBlock = parseInt(startCell.dataset.block);
            const currentHour = parseInt(currentCell.dataset.hour);
            const currentBlock = parseInt(currentCell.dataset.block);

            // Calculate the range to paint
            const startH = Math.min(startHour, currentHour);
            const endH = Math.max(startHour, currentHour);
            const startB = Math.min(startBlock, currentBlock);
            const endB = Math.max(startBlock, currentBlock);

            // Paint all cells in the range
            for (let hour = startH; hour <= endH; hour++) {
                for (let block = startB; block <= endB; block++) {
                    const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
            
                    if (cell) {
                        const cellKey = `${hour}-${block}`;
                        // Get the original color from our stored Map
                        const originalColor = dragStartColors.get(cellKey);
                        const newColor = normalizeColor(selectedColor);

                        // Only add triangle if there's an actual color change
                        if (originalColor && normalizeColor(originalColor) !== newColor) {
                            cell.classList.add('color-changed');
                            cell.style.borderColor = '#fa9d1b';
                            // cell.style.setProperty('border-top-color', originalColor);
                            cell.style.setProperty('--previous-color', originalColor);
                        } else {
                            cell.classList.remove('color-changed');
                            cell.style.borderColor = '';
                            cell.style.removeProperty('border-top-color');
                            cell.style.removeProperty('--previous-color');
                        }

                        cell.style.backgroundColor = selectedColor;
                        

                        saveBlock(cellKey, blockData[cellKey]?.text || '', cell);
                    }
                }
            }
            updateElapsedTimeBlocks();
            updateTimeSummary();
        }

        function addStripedStyle() {
            const style = document.createElement('style');
            style.textContent = `
                .elapsed-time {
                    position: relative;
                }
                
                .elapsed-time::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    pointer-events: none;
                    z-index: 2;
                }

                /* Dark pattern for light backgrounds */
                .elapsed-time.light-bg::after {
                    background-image: linear-gradient(
                        45deg,
                        rgba(0, 0, 0, 0.1) 25%,
                        transparent 25%,
                        transparent 50%,
                        rgba(0, 0, 0, 0.1) 50%,
                        rgba(0, 0, 0, 0.1) 75%,
                        transparent 75%
                    );
                    background-size: 10px 10px;
                }

                /* Light pattern for dark backgrounds */
                .elapsed-time.dark-bg::after {
                    background-image: linear-gradient(
                        45deg,
                        rgba(255, 255, 255, 0.2) 25%,
                        transparent 25%,
                        transparent 50%,
                        rgba(255, 255, 255, 0.2) 50%,
                        rgba(255, 255, 255, 0.2) 75%,
                        transparent 75%
                    );
                    background-size: 10px 10px;
                }
            `;
            document.head.appendChild(style);
        }

        function updateElapsedTimeBlocks() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            
            // Calculate blocks since 6am
            let elapsedHours = (hours - 6 + 24) % 24;
            let totalElapsedBlocks = (elapsedHours * 6) + Math.floor(minutes / 10);
            
            // Update all cells
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                const hour = parseInt(cell.dataset.hour);
                const block = parseInt(cell.dataset.block);
                const blockIndex = (hour * 6) + block;
                
                if (blockIndex < totalElapsedBlocks) {
                    cell.classList.add('elapsed-time');
                    
                    // Check background color and apply appropriate pattern
                    const bgColor = cell.style.backgroundColor;
                    if (isDarkColor(bgColor)) {
                        cell.classList.add('dark-bg');
                        cell.classList.remove('light-bg');
                    } else {
                        cell.classList.add('light-bg');
                        cell.classList.remove('dark-bg');
                    }
                } else {
                    cell.classList.remove('elapsed-time', 'dark-bg', 'light-bg');
                }
            });
        }


        /*****************
         * time summary
         */
         function updateTimeSummary() {
            const summaryContainer = document.getElementById('timeSummary');
            const colorTotals = {};

            // Initialize totals for all saved colors
            savedColors.forEach(({color, label}) => {
                colorTotals[color] = 0;
            });

            // Count blocks for each color
            Object.values(blockData).forEach(block => {
                // Convert RGB to HEX for comparison
                const blockColorHex = block.color.startsWith('rgb') ? rgbToHex(block.color) : block.color;
                
                // Find matching color in savedColors
                const matchingColor = savedColors.find(({color}) => color.toLowerCase() === blockColorHex.toLowerCase());
                
                if (matchingColor) {
                    colorTotals[matchingColor.color] += 1;
                }
            });

            // Clear existing summary
            summaryContainer.innerHTML = '';

            // Create array of color data with their total minutes
            const colorDataArray = savedColors.map(({color, label}) => {
                const blocks = colorTotals[color] || 0;
                const totalMinutes = blocks * 10;
                return {
                    color,
                    label,
                    totalMinutes,
                    hours: Math.floor(totalMinutes / 60),
                    minutes: totalMinutes % 60
                };
            });

            // Sort by total minutes (descending)
            colorDataArray.sort((a, b) => b.totalMinutes - a.totalMinutes);

            // Create summary items
            colorDataArray.forEach(({color, label, hours, minutes}) => {
                const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

                const summaryItem = document.createElement('div');
                summaryItem.className = 'color-summary-item';
                summaryItem.innerHTML = `
                    <div class="color-indicator" style="background-color: ${color}"></div>
                    <span>${label}</span>
                    <span class="time-value">${timeString}</span>
                `;
                summaryContainer.appendChild(summaryItem);
            });
        }

        /*****************
         * Save & Load
         */
         function getTimelineData() {
            return {
                colorPalette: savedColors,
                timeBlocks: blockData,
                version: "1.0"  // for future compatibility
            };
        }

        function saveTimelineToFile() {
            const data = getTimelineData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            const date = new Date().toISOString().split('T')[0];
            a.download = `timeline.json`;
            // a.download = `timeline_${date}.json`;
            a.href = url;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadTimelineFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Load color palette
                    if (data.colorPalette) {
                        savedColors = data.colorPalette;
                        initializeColorPicker();
                    }
                    
                    // Load time blocks
                    if (data.timeBlocks) {
                        Object.entries(data.timeBlocks).forEach(([key, value]) => {
                            const [hour, block] = key.split('-');
                            const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                            if (cell) {
                                blockData[key] = value;
                                cell.textContent = value.text || '';
                                cell.style.backgroundColor = value.color;

                                // Handle previous color if it exists
                                if (value.previousColor && value.previousColor !== value.color) {
                                    cell.classList.add('color-changed');
                                    cell.style.borderColor = '#fa9d1b';
                                    cell.style.setProperty('--previous-color', value.previousColor);
                                }

                                if (rgbToHex(value.color) === '#000000' || value.color === '#000000') {
                                    cell.style.color = 'white';
                                } else {
                                    cell.style.color = 'black';
                                }
                            }
                        });
                    }

                    updateTimeSummary();
                } catch (error) {
                    console.error('Error loading timeline:', error);
                    alert('Error loading timeline file');
                }
            };
            
            reader.readAsText(file);
        }

        async function loadJsonUponStart() {
            try {
                const response = await fetch('./timeline.json');
                const data = await response.json();
                
                // Load color palette
                if (data.colorPalette) {
                    savedColors = data.colorPalette;
                    initializeColorPicker();
                }
                
                // Load time blocks
                if (data.timeBlocks) {
                    Object.entries(data.timeBlocks).forEach(([key, value]) => {
                        const [hour, block] = key.split('-');
                        const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                        if (cell) {
                            blockData[key] = value;
                            cell.textContent = value.text || '';
                            cell.style.backgroundColor = value.color;

                            // Handle previous color if it exists
                            if (value.previousColor && value.previousColor !== value.color) {
                                cell.classList.add('color-changed');
                                cell.style.borderColor = '#fa9d1b';
                                cell.style.setProperty('--previous-color', value.previousColor);
                            }

                            if (rgbToHex(value.color) === '#000000' || value.color === '#000000') {
                                cell.style.color = 'white';
                            } else {
                                cell.style.color = 'black';
                            }
                        }
                    });
                }

                updateTimeSummary();
            } catch (error) {
                console.log('No timeline.json found or error loading file:', error);
            }
        }

        /*****************
         * Utils
         */
        function rgbToHex(rgb) {
            const result = rgb.match(/\d+/g);
            const hex = result.map((value) => {
                const hexValue = parseInt(value, 10).toString(16);
                return hexValue.padStart(2, '0');
            });
            return `#${hex.join('')}`;
        }

        function normalizeColor(color) {
            if (!color) return null;

            if (color.startsWith('#')) {
                return color.toLowerCase();
            }

            // If it's rgb format, convert to hex
            if (color.startsWith('rgb')) {
                const hex = rgbToHex(color);
                return hex ? hex.toLowerCase() : null;
            }
            
            return null;
        }

        function storeCurrentColors() {
            dragStartColors.clear(); // Clear previous stored colors
            document.querySelectorAll('.grid-cell').forEach(cell => {
                const key = `${cell.dataset.hour}-${cell.dataset.block}`;
                dragStartColors.set(key, cell.style.backgroundColor);
            });
        }

        function isDarkColor(color) {
            // Handle both hex and rgb formats
            let r, g, b;
            
            if (color.startsWith('#')) {
                r = parseInt(color.substr(1, 2), 16);
                g = parseInt(color.substr(3, 2), 16);
                b = parseInt(color.substr(5, 2), 16);
            } else {
                const rgb = color.match(/\d+/g);
                if (rgb) {
                    [r, g, b] = rgb.map(Number);
                }
            }
            
            // Calculate relative luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.5;
        }


        /*****************
         * Event Listener
         */

        // Initialize color picker
        document.getElementById('colorPicker').addEventListener('click', (event) => {
            if (event.target.classList.contains('color-option')) {
                selectedColor = event.target.style.backgroundColor;

            // If we're currently editing a cell, apply the color immediately
            if (currentlyEditingCell) {
                const hour = currentlyEditingCell.dataset.hour;
                const block = currentlyEditingCell.dataset.block;
                const blockKey = `${hour}-${block}`;
                
                // Get the original color
                const originalColor = dragStartColors.get(blockKey) || currentlyEditingCell.style.backgroundColor;
                const newColor = normalizeColor(selectedColor);

                // Handle color change styling
                if (originalColor && normalizeColor(originalColor) !== newColor) {
                    currentlyEditingCell.classList.add('color-changed');
                    currentlyEditingCell.style.borderColor = '#fa9d1b';
                    currentlyEditingCell.style.setProperty('--previous-color', originalColor);
                } else {
                    currentlyEditingCell.classList.remove('color-changed');
                    currentlyEditingCell.style.borderColor = '';
                    currentlyEditingCell.style.removeProperty('--previous-color');
                }

                // Apply the new color
                currentlyEditingCell.style.backgroundColor = selectedColor;

                // Update blockData with the new color and existing text
                const textarea = currentlyEditingCell.querySelector('.editing-textarea');
                const currentText = textarea ? textarea.value : (blockData[blockKey]?.text || '');
                
                // Save to blockData
                blockData[blockKey] = {
                    text: currentText,
                    color: selectedColor,
                    previousColor: originalColor || null
                };
                
                // Keep the textarea focused and maintain text color
                if (textarea) {
                    textarea.style.backgroundColor = 'transparent';
                    if (rgbToHex(selectedColor) === '#000000') {
                        textarea.style.color = 'white';
                    } else {
                        textarea.style.color = 'black';
                    }
                    textarea.focus();
                }

                updateTimeSummary();
            }
            }
        });

        // Initialize grid when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeGrid();
            initializeColorPicker();  

            loadJsonUponStart();

            addStripedStyle();
            updateElapsedTimeBlocks(); // Initial update

            
            // Save button click handler
            document.getElementById('saveButton').addEventListener('click', saveTimelineToFile);
            
            // Load button click handler
            document.getElementById('loadButton').addEventListener('click', () => {
                document.getElementById('loadInput').click();
            });
            
            // File input change handler
            document.getElementById('loadInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadTimelineFromFile(e.target.files[0]);
                }
            });
            
            // Keyboard shortcut for save (Cmd/Ctrl + S)
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault();
                    saveTimelineToFile();
                }
            });


            // Update every minute
            setInterval(updateElapsedTimeBlocks, 60000);
        });
    </script>
</body>
</html>
