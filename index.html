<!DOCTYPE html>
<html>
<head>
    <style>
        /* Container wrapper to maintain relative positioning */
        .container-wrapper {
            position: relative;
            max-width: 200px;
            margin: 0 auto;
        }

        /************************
        * time blocks
        */
        .grid-container {
            display: grid;
            grid-template-columns: 60px repeat(6, 1fr);
            gap: 1px;
            background-color: #eee;
            /* padding: 10px; */
            max-width: 200px;
            margin: 0 auto;
        }

        .header-cell {
            background-color: #f8f9fa;
            padding: 8px;
            /* width: 30px;  */
            text-align: center;
            font-weight: bold;
        }

        .time-cell {
            background-color: #f8f9fa;
            padding: 8px;
            text-align: right;
        }

        .grid-cell {
            background-color: white;
            min-height: 24px;
            border: 1px solid #ddd;
            padding: 4px;
            cursor: pointer;
            position: relative;
            /* overflow: hidden; */
            overflow: visible;
            white-space: nowrap; 
            z-index: 1; 
        }

        .grid-cell:hover {
            border-color: #aaa;
        }

        /************************
        * color picker
        */

        .color-picker {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 20px;
            max-width: 200px;
            margin: 0 auto;
            align-items: center;
            position: relative;
        }

        .add-color-btn {
            width: 32px;
            height: 32px;
            border: 2px dashed #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: white;
        }

        .add-color-btn:hover {
            border-color: #666;
        }

        .color-picker-popup {
            position: absolute;
            top: 100%;
            right: 20px;
            min-width: 200px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .color-picker-popup.show {
            display: block;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .color-input-group input {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-option:hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }

        #colorInput {
            margin-bottom: 10px;
        }

        .editing-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #4299e1;
            padding: 4px;
            resize: none;
            font-family: inherit;
            font-size: inherit;
            box-sizing: border-box;
            background-color: transparent; /* time-block을 클릭하자마자 색칠되게 한다 */
        }


        /************************
        * save & load 
        */

        .floating-controls {
            position: absolute;
            top: 100%;
            right: -100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            fill: #666;
        }

        #loadInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container-wrapper">
        <div class="grid-container" id="timeGrid">
            <!-- Grid will be populated by JavaScript -->
            <!-- <div class="data-controls">
                <button id="saveButton" class="control-btn">Save Timeline</button>
                <input type="file" id="loadInput" accept=".json" style="display: none;">
                <button id="loadButton" class="control-btn">Load Timeline</button>
            </div> -->
        </div>

        <div class="floating-controls">
            <button id="saveButton" class="control-btn" title="Save Timeline">
                <svg viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
            </button>
            <button id="loadButton" class="control-btn" title="Load Timeline">
                <svg viewBox="0 0 24 24">
                    <path d="M5 15h14l-7-7-7 7z"/>
                </svg>
            </button>
            <input type="file" id="loadInput" accept=".json">
        </div>
    </div>

    <div class="color-picker" id="colorPicker">
        <!-- <div class="color-option" style="background-color: #a5d8ff"></div> -->
        <!-- <div class="color-option" style="background-color: #ffd8a8"></div> -->

        <!-- Color options will be populated by JavaScript -->
        <button class="add-color-btn" id="addColorBtn">+</button>
        <div class="color-picker-popup" id="colorPickerPopup">
            <div class="color-input-group">
                <input type="color" id="colorInput" value="#a5d8ff">
                <input type="text" id="colorLabel" placeholder="Enter color label">
            </div>
            <button class="save-btn" id="saveColorBtn">Add Color</button>
        </div>
    </div>



    <script>
        let selectedColor = '#a5d8ff';
        const blockData = {};
        let savedColors = [
            { color: '#ffffff', label: 'Rest' },
            { color: '#000000', label: 'Sleep' },
            { color: '#44f275', label: 'Learn' },
            { color: '#fcff5e', label: 'Fun' },
            { color: '#38adf5', label: 'Prep' },
            { color: '#ed2a02', label: '운동' },
        ];

        //drag multiple time-blocks
        let isDragging = false;
        let startCell = null;

        function initializeGrid() {
            const grid = document.getElementById('timeGrid');

            // Add header row
            grid.appendChild(createCell('Hour', 'header-cell'));
            for (let i = 1; i <= 6; i++) {
                grid.appendChild(createCell(`${i}0m`, 'header-cell'));
            }

            // Create time blocks
            for (let hour = 0; hour < 24; hour++) {
                const displayHour = (hour + 6) % 24;
                grid.appendChild(createCell(
                    `${String(displayHour).padStart(2, '0')}:00`,
                    'time-cell'
                ));

                for (let block = 0; block < 6; block++) {
                    const cell = createCell('', 'grid-cell');
                    cell.dataset.hour = hour;
                    cell.dataset.block = block;


                    cell.addEventListener('click', handleCellClick);
                    // Add mouse events for drag selection
                    cell.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startCell = cell;
                        handleCellClick(e); // Handle initial click
                    });

                    cell.addEventListener('mouseover', (e) => {
                        if (isDragging && e.buttons === 1) { // Check if left mouse button is pressed
                            handleDragPaint(startCell, cell);
                        }
                    });

                    grid.appendChild(cell);
                }
            }

            // Add mouseup event to document to handle drag end
            document.addEventListener('mouseup', () => {
                isDragging = false;
                startCell = null;
            });

            // Prevent text selection while dragging
            grid.addEventListener('selectstart', (e) => {
                if (isDragging) {
                    e.preventDefault();
                }
            });
        }

        function createCell(text, className) {
            const cell = document.createElement('div');
            cell.className = className;
            cell.textContent = text;
            return cell;
        }

        function handleCellClick(event) {
            // const cell = event.target;
            const cell = event.target.classList.contains('grid-cell') ? 
                event.target : 
                event.target.closest('.grid-cell');
            
            if (!cell) return;

            const hour = cell.dataset.hour;
            const block = cell.dataset.block;
            const blockKey = `${hour}-${block}`;

            cell.style.backgroundColor = selectedColor;

            // Remove any existing textarea
            const existingTextarea = document.querySelector('.editing-textarea');
            if (existingTextarea) {
                existingTextarea.remove();
            }

            // Create and add new textarea
            const textarea = document.createElement('textarea');
            textarea.className = 'editing-textarea';
            textarea.value = blockData[blockKey]?.text || '';
            textarea.style.backgroundColor = 'transparent';
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveBlock(blockKey, textarea.value, cell);
                    textarea.remove();
                }
            });

            cell.appendChild(textarea);
            textarea.focus();
        }


        function saveBlock(blockKey, text, cell) {
            blockData[blockKey] = {
                text: text,
                color: selectedColor
            };

            // Update cell display
            cell.textContent = text;
            cell.style.backgroundColor = selectedColor;
            
            // Set text color to white if background is black
            if (rgbToHex(selectedColor) === '#000000') {
                cell.style.color = 'white';
            } else {
                cell.style.color = 'black';  // Reset to default for other colors
            }
        }

        // Initialize color picker
        function initializeColorPicker() {
            const colorPicker = document.getElementById('colorPicker');
            const addColorBtn = document.getElementById('addColorBtn');
            const popup = document.getElementById('colorPickerPopup');
            const colorInput = document.getElementById('colorInput');
            const colorLabel = document.getElementById('colorLabel');
            const saveColorBtn = document.getElementById('saveColorBtn');


            // Clear existing color options except the add button and popup
            const children = Array.from(colorPicker.children);
            children.forEach(child => {
                if (child !== addColorBtn && child !== popup) {
                    child.remove();
                }
            });

            // Add color options
            savedColors.forEach(({color, label}) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.dataset.label = label; // This enables the hover tooltip
                colorOption.addEventListener('click', () => {
                    selectedColor = color;
                });
                colorPicker.insertBefore(colorOption, addColorBtn);
            });

            // Add color button handler
            addColorBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                popup.classList.toggle('show');
                colorLabel.value = ''; // Reset label input
            });

            // Save color button handler
            saveColorBtn.addEventListener('click', () => {
                const newColor = colorInput.value;
                const newLabel = colorLabel.value.trim() || newColor; // Use color code if no label provided
                
                if (!savedColors.some(c => c.color === newColor)) {
                    savedColors.push({
                        color: newColor,
                        label: newLabel
                    });
                    initializeColorPicker();  // Refresh color picker
                }
                popup.classList.remove('show');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!popup.contains(e.target) && e.target !== addColorBtn) {
                    popup.classList.remove('show');
                }
            });
        }

        // Add this function to handle drag painting
        function handleDragPaint(startCell, currentCell) {
            // Get row and column indices
            const startHour = parseInt(startCell.dataset.hour);
            const startBlock = parseInt(startCell.dataset.block);
            const currentHour = parseInt(currentCell.dataset.hour);
            const currentBlock = parseInt(currentCell.dataset.block);

            // Calculate the range to paint
            const startH = Math.min(startHour, currentHour);
            const endH = Math.max(startHour, currentHour);
            const startB = Math.min(startBlock, currentBlock);
            const endB = Math.max(startBlock, currentBlock);

            // Paint all cells in the range
            for (let hour = startH; hour <= endH; hour++) {
                for (let block = startB; block <= endB; block++) {
                    const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                    if (cell) {
                        cell.style.backgroundColor = selectedColor;
                        if (selectedColor === '#000000') {
                            cell.style.color = 'white';
                        } else {
                            cell.style.color = 'black';
                        }
                        // Save the cell data
                        const blockKey = `${hour}-${block}`;
                        blockData[blockKey] = {
                            text: blockData[blockKey]?.text || '',
                            color: selectedColor
                        };
                    }
                }
            }
        }

        /*****************
         * Save & Load
         */
         function getTimelineData() {
            return {
                colorPalette: savedColors,
                timeBlocks: blockData,
                version: "1.0"  // for future compatibility
            };
        }

        function saveTimelineToFile() {
            const data = getTimelineData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            const date = new Date().toISOString().split('T')[0];
            a.download = `timeline_${date}.json`;
            a.href = url;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadTimelineFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Load color palette
                    if (data.colorPalette) {
                        savedColors = data.colorPalette;
                        initializeColorPicker();
                    }
                    
                    // Load time blocks
                    if (data.timeBlocks) {
                        Object.entries(data.timeBlocks).forEach(([key, value]) => {
                            const [hour, block] = key.split('-');
                            const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                            if (cell) {
                                blockData[key] = value;
                                cell.textContent = value.text || '';
                                cell.style.backgroundColor = value.color;
                                if (value.color === '#000000') {
                                    cell.style.color = 'white';
                                } else {
                                    cell.style.color = 'black';
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading timeline:', error);
                    alert('Error loading timeline file');
                }
            };
            
            reader.readAsText(file);
        }

        async function loadJsonUponStart() {
            // Then load timeline.json
            try {
                const response = await fetch('default_timeline.json');
                const data = await response.json();
                
                // Load color palette
                if (data.colorPalette) {
                    savedColors = data.colorPalette;
                    initializeColorPicker();
                }
                
                // Load time blocks
                if (data.timeBlocks) {
                    Object.entries(data.timeBlocks).forEach(([key, value]) => {
                        const [hour, block] = key.split('-');
                        const cell = document.querySelector(`.grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                        if (cell) {
                            blockData[key] = value;
                            cell.textContent = value.text || '';
                            cell.style.backgroundColor = value.color;
                            if (value.color === '#000000') {
                                cell.style.color = 'white';
                            } else {
                                cell.style.color = 'black';
                            }
                        }
                    });
                }
            } catch (error) {
                console.log('No timeline.json found or error loading file:', error);
            }
        }

        /*****************
         * Utils
         */
        function rgbToHex(rgb) {
            const result = rgb.match(/\d+/g);
            const hex = result.map((value) => {
                const hexValue = parseInt(value, 10).toString(16);
                return hexValue.padStart(2, '0');
            });
            return `#${hex.join('')}`;
        }

        /*****************
         * Event Listener
         */

        // Initialize color picker
        document.getElementById('colorPicker').addEventListener('click', (event) => {
            if (event.target.classList.contains('color-option')) {
                selectedColor = event.target.style.backgroundColor;
            }
        });

        // Initialize grid when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeGrid();
            initializeColorPicker();  

            loadJsonUponStart();

            
            // Save button click handler
            document.getElementById('saveButton').addEventListener('click', saveTimelineToFile);
            
            // Load button click handler
            document.getElementById('loadButton').addEventListener('click', () => {
                document.getElementById('loadInput').click();
            });
            
            // File input change handler
            document.getElementById('loadInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadTimelineFromFile(e.target.files[0]);
                }
            });
            
            // Keyboard shortcut for save (Cmd/Ctrl + S)
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault();
                    saveTimelineToFile();
                }
            });
        });
    </script>
</body>
</html>
