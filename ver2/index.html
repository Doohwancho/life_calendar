<!DOCTYPE html>
<html>
<head>
    <style>
        .main-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            /* margin: 0 auto; */
            /* margin-left: 600px; */
            position: relative;
            width: fit-content;
            left: 20%;
        }

        .vertical-divider {
            width: 60px;
            background-color: #eee;
            margin: 0 20px;
        }

        /* Container wrapper to maintain relative positioning */
        .left-container {
            position: relative;
            /* max-width: 200px; */
            margin: 0 auto;
            /* justify-content: center; */
        }

        .timeline-container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .right-container {
            position: fixed;
            /* max-width: 200px; */
            bottom: 0;
            margin: 0 auto;
            justify-content: center;
        }

        /************************
        * time blocks
        */
        .grid-container {
            display: grid;
            grid-template-columns: 60px repeat(6, 1fr);
            gap: 1px;
            background-color: #eee;
            /* padding: 10px; */
            max-width: 200px;
            margin: 0 auto;
        }

        .header-cell {
            background-color: #f8f9fa;
            padding: 8px;
            /* width: 30px;  */
            text-align: center;
            font-weight: bold;
            user-select: none;  
        }

        .time-cell {
            background-color: #f8f9fa;
            padding: 8px;
            text-align: right;
            user-select: none;  
        }

        .grid-cell {
            background-color: white;
            /* min-height: 24px; */
            /* width: 30px; */
            max-width: 70px;
            border: 1px solid #ddd;
            padding: 4px;
            cursor: pointer;
            position: relative;
            white-space: nowrap; 
            overflow: hidden;
            z-index: 1; 
        }

        .grid-cell:hover {
            border-color: #aaa;
        }

        /************************
        * time summary 
        */
        .time-summary {
            position: absolute;
            /* top: 100%; */
            right: -110%;

            margin-top: 45px; /* Align with grid top */
            min-width: 180px;
            width: 230px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            /* position: sticky; */
            /* left: 100%; */
            /* height: fit-content; */
        }

        .color-summary-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .ranking {
            text-align: right;
            flex-shrink: 0;
            margin-right: 8px;
            font-weight: bold;
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }

        .label {
            flex: 1;
            margin-right: 8px;
        }

        .rank-up, .rank-down {
            width: 20px;
            text-align: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .rank-up {
            color: #e53e3e;
        }

        .rank-down {
            color: #3182ce;
        }
        .time-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .time-value {
            width: 55px;  /* Fixed width for time value */
            text-align: right;
            font-family: monospace;
        }

        .time-change {
            width: 65px;  /* Fixed width for time change */
            font-size: 12px;
            color: #666;
            text-align: right;
        }

        /************************
        * color picker
        */
        .color-picker {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 20px;
            max-width: 200px;
            margin: 0 auto;
            align-items: center;
            position: relative;
        }

        .add-color-btn {
            width: 32px;
            height: 32px;
            border: 2px dashed #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: white;
        }

        .add-color-btn:hover {
            border-color: #666;
        }

        .color-picker-popup {
            position: absolute;
            top: 100%;
            right: 20px;
            min-width: 200px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .color-picker-popup.show {
            display: block;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .color-input-group input {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-option:hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }

        #colorInput {
            margin-bottom: 10px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
            animation: fadeIn 0.2s ease-out;
        }

        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            width: 400px;
            height: 220px;
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            animation: slideIn 0.3s ease-out;
            color: black;
        }

        .editing-textarea {
            /* width: 200px; */
            width: 100%;
            height: 85%;
            border: 2px solid #4299e1;
            padding: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: inherit;
            box-sizing: border-box;
            background-color: transparent; /* time-block을 클릭하자마자 색칠되게 한다 */
            z-index: 10;
            /* box-shadow: 0 2px 10px rgba(0,0,0,0.1); */
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            padding-top: 8px;
            gap: 12px;
        }

        .modal-button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .save-text-button, .cancel-text-button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .save-text-button {
            background-color: #4299e1;
            color: white;
        }

        .save-text-button:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }

        .save-text-button:active {
            transform: translateY(0);
        }

        .cancel-text-button {
            background-color: #f7f1ed;
            color: #4a5568;
        }

        .cancel-text-button:hover {
            background-color: #e2e8f0;
            transform: translateY(-1px);
        }

        .cancel-text-button:active {
            transform: translateY(0);
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }



        /************************
        * save & load 
        */

        .floating-controls {
            position: relative;
            top: 90%;
            /* bottom: 0%; */
            /* right: -100%; */
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            fill: #666;
        }

        #loadInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="main-layout">

        <div class="left-container">
            <div class="time-summary" id="timeSummary">
                <!-- Summary will be populated by JavaScript -->
            </div>

            <div class="floating-controls">
                <button id="saveButton" class="control-btn" title="Save Timeline">
                    <svg viewBox="0 0 24 24">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                </button>
                <button id="loadButton" class="control-btn" title="Load Timeline">
                    <svg viewBox="0 0 24 24">
                        <path d="M5 15h14l-7-7-7 7z"/>
                    </svg>
                </button>
                <input type="file" id="loadInput" accept=".json">
            </div>
        </div>

        <div class="timeline-container">
            <div class="grid-wrapper">
                <div class="grid-label">Current Timeline</div>
                <div class="grid-container" id="timeGrid">
                    <!-- Grid will be populated by JavaScript -->
                </div>
            </div>

            <div class="vertical-divider"></div>

            <div class="grid-wrapper">
                <div class="grid-label">Goal Timeline</div>
                <div class="grid-container" id="goalTimeGrid">
                    <!-- Second grid will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="right-container"> 
            <div class="color-picker" id="colorPicker">
                <!-- Color options will be populated by JavaScript -->
                <!-- <div class="color-option" style="background-color: #a5d8ff"></div> -->

                <button class="add-color-btn" id="addColorBtn">+</button>
                <div class="color-picker-popup" id="colorPickerPopup">
                    <div class="color-input-group">
                        <input type="color" id="colorInput" value="#a5d8ff">
                        <input type="text" id="colorLabel" placeholder="Enter color label">
                    </div>
                    <button class="save-btn" id="saveColorBtn">Add Color</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        let activeGrid = 'timeGrid'; //track which grid we're working with
        let selectedColor = 'rgb(255, 255, 255)'; //default cell-background-color is white

        const blockData = {}; //모든 cell의 text, color, prev_color가 담긴 변수, for main timeline
        const goalBlockData = {}; // for goal timeline

        let previousColorTotals = {}; //실시간 시간 증감 tracking을 위한 변수

        let timeGridStartColors = new Map(); // For current timeline, store original colors when drag starts
        let goalGridStartColors = new Map(); // For goal timeline, store original colors when drag starts

        let selectedCells = new Set();

        let savedColors = [
            { color: '#ffffff', label: 'Rest' },
            { color: '#000000', label: 'Sleep' },
            { color: '#44f275', label: 'Learn' },
            { color: '#fcff5e', label: 'Fun' },
            { color: '#38adf5', label: 'Prep' },
            { color: '#ed2a02', label: '운동' },
        ];

        //drag multiple time-blocks
        let isDragging = false;
        let startCell = null;

        //style for previous color inside time-block
        const previousColorStyle = `
            .grid-cell.color-changed {
                padding-left: 16px;
                position: relative;
            }

            .grid-cell.color-changed::before {
                content: '';
                position: absolute;
                top: -3px;
                left: -3px;
                border-style: solid;
                border-width: 12px 12px 0 0;
                border-right-color: transparent;
                border-top-color: var(--previous-color);
            }
            `;

        // Add the styles to the document
        const styleSheet = document.createElement("style");
        styleSheet.textContent = previousColorStyle;
        document.head.appendChild(styleSheet);

        // variable for editting cell
        let currentlyEditingCell = null;


        function initializeGrid(gridId) {
            const grid = document.getElementById(gridId);
            const dataStore = gridId === 'timeGrid' ? blockData : goalBlockData;

            // Add header row
            grid.appendChild(createCell('Hour', 'header-cell'));
            for (let i = 1; i <= 6; i++) {
                grid.appendChild(createCell(`${i}0m`, 'header-cell'));
            }

            // Create time blocks
            for (let hour = 0; hour < 24; hour++) {
                const displayHour = (hour + 6) % 24;
                grid.appendChild(createCell(
                    `${String(displayHour).padStart(2, '0')}:00`,
                    'time-cell'
                ));

                for (let block = 0; block < 6; block++) {
                    const cell = createCell('', 'grid-cell');
                    cell.dataset.hour = hour;
                    cell.dataset.block = block;

                    // Initialize data store with default values for each cell
                    const blockKey = `${hour}-${block}`;
                    dataStore[blockKey] = {
                        text: '',
                        color: 'rgb(255, 255, 255)',  // default white color
                        previousColor: null
                    };

                    // Add mouse events for drag selection
                    cell.addEventListener('mousedown', (e) => {
                        isDragging = false;
                        startCell = cell;
                        selectedCells.clear();

                        storeCurrentColors(gridId);

                        // Add initial cell to selected set
                        const cellKey = `${hour}-${block}`;
                        selectedCells.add(cellKey);
                    });

                    cell.addEventListener('mousemove', (e) => {
                        if (e.buttons === 1 && startCell) {
                            const currentHour = cell.dataset.hour;
                            const currentBlock = cell.dataset.block;
                            const cellKey = `${currentHour}-${currentBlock}`;
                            
                            // Add cell to selected set
                            selectedCells.add(cellKey);
                            
                            // If more than one cell is selected, it's a drag
                            if (selectedCells.size > 1) {
                                isDragging = true;
                                handleDragPaint(startCell, cell);
                            }
                        }
                    });

                    // Handle single cell click
                    cell.addEventListener('mouseup', (e) => {
                        if (!isDragging && selectedCells.size === 1) {
                            handleCellClick(e);
                        }
                        selectedCells.clear();
                    });

                    grid.appendChild(cell);
                }
            }

            // Add mouseup event to document to handle drag end
            document.addEventListener('mouseup', () => {
                isDragging = false;
                startCell = null;
                timeGridStartColors.clear();
                goalGridStartColors.clear();
                selectedCells.clear();
            });

            // Prevent text selection while dragging
            grid.addEventListener('selectstart', (e) => {
                if (isDragging) {
                    e.preventDefault();
                }
            });
        }

        function createCell(text, className) {
            const cell = document.createElement('div');
            cell.className = className;
            cell.textContent = text;
            if (className === 'grid-cell') {
                // Explicitly set initial background color
                cell.style.backgroundColor = 'rgb(255, 255, 255)';  // set default background color to white
            }
            return cell;
        }

        function handleCellClick(event) {
            const cell = event.target.classList.contains('grid-cell') ? 
                event.target : 
                event.target.closest('.grid-cell');
            
            if (!cell) return;

            const gridId = cell.closest('.grid-container').id;
            const colorStore = gridId === 'timeGrid' ? timeGridStartColors : goalGridStartColors;
            activeGrid = cell.closest('.grid-container').id;

            // Create modal elements
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';

            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';

            // Create textarea
            const textarea = document.createElement('textarea');
            textarea.className = 'editing-textarea';
            textarea.value = cell.textContent || '';
            
            // Create buttons
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'modal-buttons';

            const saveButton = document.createElement('button');
            saveButton.className = 'modal-button save-text-button';
            saveButton.textContent = 'Save';

            const cancelButton = document.createElement('button');
            cancelButton.className = 'modal-button cancel-text-button';
            cancelButton.textContent = 'Cancel';

            // Add event listeners
            // Close modal when press 'esc'
            const handleEscKey = (e) => {
                if (e.key === 'Escape') {
                    modalOverlay.remove();
                    // Remove the event listener when modal is closed
                    document.removeEventListener('keydown', handleEscKey);
                }
            };

            document.addEventListener('keydown', handleEscKey);


            saveButton.addEventListener('click', () => {
                const hour = cell.dataset.hour;
                const block = cell.dataset.block;
                const blockKey = `${hour}-${block}`;
                
                saveBlock(blockKey, textarea.value, cell);
                modalOverlay.remove();
                document.removeEventListener('keydown', handleEscKey);
            });

            cancelButton.addEventListener('click', () => {
                modalOverlay.remove();
                document.removeEventListener('keydown', handleEscKey);
            });

            // Close modal when clicking outside
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                    document.removeEventListener('keydown', handleEscKey);
                }
            });


            // Handle Enter key
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const hour = cell.dataset.hour;
                    const block = cell.dataset.block;
                    const blockKey = `${hour}-${block}`;
                    
                    saveBlock(blockKey, textarea.value, cell);
                    modalOverlay.remove();
                }
            });

            // Assemble modal
            buttonsDiv.appendChild(cancelButton);
            buttonsDiv.appendChild(saveButton);
            modalContent.appendChild(textarea);
            modalContent.appendChild(buttonsDiv);
            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Focus textarea
            textarea.focus();

            // Handle the cell color changes
            const hour = cell.dataset.hour;
            const block = cell.dataset.block;
            const blockKey = `${hour}-${block}`;

            const originalColor = colorStore.get(blockKey) || 'rgb(255, 255, 255)';
            const newColor = normalizeColor(selectedColor);

            if (originalColor && normalizeColor(originalColor) !== newColor) {
                cell.classList.add('color-changed');
                cell.style.setProperty('--previous-color', originalColor);
            } else {
                cell.classList.remove('color-changed');
                cell.style.borderColor = '';
                cell.style.removeProperty('--previous-color');
            }

            cell.style.backgroundColor = selectedColor;
            
            // Update blockData
            blockData[blockKey] = {
                text: blockData[blockKey]?.text || '',
                color: selectedColor,
                previousColor: originalColor || null
            };

            updateTimeSummary();
        }

        function saveBlock(blockKey, text, cell) {
            const gridId = cell.closest('.grid-container').id;
            const dataStore = gridId === 'timeGrid' ? blockData : goalBlockData;
            const colorStore = gridId === 'timeGrid' ? timeGridStartColors : goalGridStartColors;

            // Get the current previous color if it exists
            const previousColor = colorStore.get(blockKey);
        
            dataStore[blockKey] = {
                text: text,
                color: selectedColor,
                previousColor: previousColor || null  
            };

            // Update cell display
            cell.textContent = text;
            cell.style.backgroundColor = selectedColor;

            // Set text color to white if background is black
            if (rgbToHex(selectedColor) === '#000000') {
                cell.style.color = 'white';
            } else {
                cell.style.color = 'black';  // Reset to default for other colors
            }
        }

        // Initialize color picker
        function initializeColorPicker() {
            const colorPicker = document.getElementById('colorPicker');
            const addColorBtn = document.getElementById('addColorBtn');
            const popup = document.getElementById('colorPickerPopup');
            const colorInput = document.getElementById('colorInput');
            const colorLabel = document.getElementById('colorLabel');
            const saveColorBtn = document.getElementById('saveColorBtn');


            // Clear existing color options except the add button and popup
            const children = Array.from(colorPicker.children);
            children.forEach(child => {
                if (child !== addColorBtn && child !== popup) {
                    child.remove();
                }
            });

            // Add color options
            savedColors.forEach(({color, label}) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.dataset.label = label; // This enables the hover tooltip
                colorOption.addEventListener('click', () => {
                    selectedColor = color;
                });
                colorPicker.insertBefore(colorOption, addColorBtn);
            });

            // Add color button handler
            addColorBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                popup.classList.toggle('show');
                colorLabel.value = ''; // Reset label input
            });

            // Save color button handler
            saveColorBtn.addEventListener('click', () => {
                const newColor = colorInput.value;
                const newLabel = colorLabel.value.trim() || newColor; // Use color code if no label provided
                
                if (!savedColors.some(c => c.color === newColor)) {
                    savedColors.push({
                        color: newColor,
                        label: newLabel
                    });
                    initializeColorPicker();  // Refresh color picker
                }
                popup.classList.remove('show');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!popup.contains(e.target) && e.target !== addColorBtn) {
                    popup.classList.remove('show');
                }
            });
        }


        // Add this function to handle drag painting
        function handleDragPaint(startCell, currentCell) {
            // Get the grid we're working with
            const gridId = startCell.closest('.grid-container').id;
            const dataStore = gridId === 'timeGrid' ? blockData : goalBlockData;
            const colorStore = gridId === 'timeGrid' ? timeGridStartColors : goalGridStartColors;

            // Get row and column indices
            const startHour = parseInt(startCell.dataset.hour);
            const startBlock = parseInt(startCell.dataset.block);
            const currentHour = parseInt(currentCell.dataset.hour);
            const currentBlock = parseInt(currentCell.dataset.block);

            // Calculate the range to paint
            const startH = Math.min(startHour, currentHour);
            const endH = Math.max(startHour, currentHour);
            const startB = Math.min(startBlock, currentBlock);
            const endB = Math.max(startBlock, currentBlock);

            // Paint all cells in the range
            for (let hour = startH; hour <= endH; hour++) {
                for (let block = startB; block <= endB; block++) {
                    const cell = document.querySelector(`#${gridId} .grid-cell[data-hour="${hour}"][data-block="${block}"]`);
            
                    if (cell) {
                        const cellKey = `${hour}-${block}`;
                        // Get the original color from our stored Map
                        const originalColor = colorStore.get(cellKey); //before) dragStartColors.get(cellKey);
                        const newColor = normalizeColor(selectedColor);

                        // Only add triangle if there's an actual color change
                        if (originalColor && normalizeColor(originalColor) !== newColor) {
                            cell.classList.add('color-changed');
                            // cell.style.borderColor = '#fa9d1b';
                            // cell.style.setProperty('border-top-color', originalColor);
                            cell.style.setProperty('--previous-color', originalColor);
                        } else {
                            cell.classList.remove('color-changed');
                            cell.style.borderColor = '';
                            cell.style.removeProperty('border-top-color');
                            cell.style.removeProperty('--previous-color');
                        }

                        cell.style.backgroundColor = selectedColor;
                        

                        saveBlock(cellKey, dataStore[cellKey]?.text || '', cell);
                    }
                }
            }
            updateElapsedTimeBlocks();
            updateTimeSummary();
        }

        function addStripedStyle() {
            //feat) 6시부터 현재시간까지 지난 시간은 빗금표시한다. 
            const style = document.createElement('style');
            style.textContent = `
                .elapsed-time {
                    position: relative;
                }
                
                .elapsed-time::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    pointer-events: none;
                    z-index: 2;
                }

                /* Dark pattern for light backgrounds */
                .elapsed-time.light-bg::after {
                    background-image: linear-gradient(
                        45deg,
                        rgba(0, 0, 0, 0.1) 25%,
                        transparent 25%,
                        transparent 50%,
                        rgba(0, 0, 0, 0.1) 50%,
                        rgba(0, 0, 0, 0.1) 75%,
                        transparent 75%
                    );
                    background-size: 10px 10px;
                }

                /* Light pattern for dark backgrounds */
                .elapsed-time.dark-bg::after {
                    background-image: linear-gradient(
                        45deg,
                        rgba(255, 255, 255, 0.2) 25%,
                        transparent 25%,
                        transparent 50%,
                        rgba(255, 255, 255, 0.2) 50%,
                        rgba(255, 255, 255, 0.2) 75%,
                        transparent 75%
                    );
                    background-size: 10px 10px;
                }
            `;
            document.head.appendChild(style);
        }

        function addCurrentTimeRedLineStyle() {
            const currentTimeStyle = `
                .current-time-block {
                    position: relative;
                }

                .current-time-block::after{
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    bottom: 0;
                    width: 3px;
                    background-color: #ff0000;
                    z-index: 3;
                }
            `;

            // Add the styles to the document
            const currentTimeStyleSheet = document.createElement("style");
            currentTimeStyleSheet.textContent = currentTimeStyle;
            document.head.appendChild(currentTimeStyleSheet);
        }

        function updateElapsedTimeBlocks() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            
            // Calculate blocks since 6am
            let elapsedHours = (hours - 6 + 24) % 24;
            let totalElapsedBlocks = (elapsedHours * 6) + Math.floor(minutes / 10);

            // Calculate current block
            const currentHour = (hours - 6 + 24) % 24;
            const currentBlock = Math.floor(minutes / 10);
            
            // Update all cells
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                // Remove current time block marker from all cells first
                cell.classList.remove('current-time-block');

                const hour = parseInt(cell.dataset.hour);
                const block = parseInt(cell.dataset.block);
                const blockIndex = (hour * 6) + block;
                
                if (blockIndex < totalElapsedBlocks) {
                    cell.classList.add('elapsed-time');
                    
                    // Check background color and apply appropriate pattern
                    const bgColor = cell.style.backgroundColor;
                    if (isDarkColor(bgColor)) {
                        cell.classList.add('dark-bg');
                        cell.classList.remove('light-bg');
                    } else {
                        cell.classList.add('light-bg');
                        cell.classList.remove('dark-bg');
                    }
                } else {
                    cell.classList.remove('elapsed-time', 'dark-bg', 'light-bg');
                }

                // Mark current time block
                if (hour === currentHour && block === currentBlock) {
                    cell.classList.add('current-time-block');
                }
            });
        }


        /*****************
         * time summary
         */
         function calculatePreviousRankings(colorTotals, timeChanges) {
            // Calculate previous totals by subtracting changes
            const previousTotals = {};
            Object.keys(colorTotals).forEach(color => {
                // colorTotals is in blocks (10-minute units)
                const currentBlocks = colorTotals[color] || 0;
                const changeBlocks = timeChanges[color] || 0;
                
                // Calculate previous blocks
                const previousBlocks = currentBlocks - changeBlocks;
                // Convert to minutes
                previousTotals[color] = previousBlocks * 10;
            });

            // Create array and sort by previous totals
            const previousRankings = savedColors.map(({color, label}) => ({
                color,
                label,
                totalMinutes: Math.max(0, previousTotals[color] || 0) // Ensure non-negative
            }));

            previousRankings.sort((a, b) => b.totalMinutes - a.totalMinutes);
            
            // Create ranking map
            const rankMap = new Map();
            previousRankings.forEach((item, index) => {
                rankMap.set(item.color, index + 1);
            });
            
            return rankMap;
        }

        function updateTimeSummary() {
            const summaryContainer = document.getElementById('timeSummary');
            const colorTotals = {};
            const timeChanges = {};

            // Initialize totals for all saved colors
            savedColors.forEach(({color}) => {
                colorTotals[color] = 0;
                timeChanges[color] = 0;
            });

            // Count blocks and track changes
            Object.values(blockData).forEach(block => {
                const currentColorHex = block.color.startsWith('rgb') ? rgbToHex(block.color) : block.color;
                const previousColorHex = block.previousColor ? 
                    (block.previousColor.startsWith('rgb') ? rgbToHex(block.previousColor) : block.previousColor) : 
                    null;

                // Count current color
                if (savedColors.find(c => c.color.toLowerCase() === currentColorHex.toLowerCase())) {
                    colorTotals[currentColorHex] += 1;
                    
                    // If there was a color change in this cell
                    if (previousColorHex && previousColorHex !== currentColorHex) {
                        timeChanges[currentColorHex] += 1;  // +1 block for new color
                        if (savedColors.find(c => c.color.toLowerCase() === previousColorHex.toLowerCase())) {
                            timeChanges[previousColorHex] -= 1;  // -1 block for old color
                        }
                    }
                }
            });

            // Get previous rankings
            const previousRankings = calculatePreviousRankings(colorTotals, timeChanges);

            // Create array of color data with their totals
            const colorDataArray = savedColors.map(({color, label}) => {
                const blocks = colorTotals[color] || 0;
                const totalMinutes = blocks * 10;
                const change = timeChanges[color] * 10;  // Convert blocks to minutes
                
                return {
                    color,
                    label,
                    totalMinutes,
                    hours: Math.floor(totalMinutes / 60),
                    minutes: totalMinutes % 60,
                    change
                };
            });

            // Sort by total minutes (descending)
            colorDataArray.sort((a, b) => b.totalMinutes - a.totalMinutes);

            // Clear existing summary
            summaryContainer.innerHTML = '';

            // Create summary items
            colorDataArray.forEach((data, index) => {
                const currentRank = index + 1;
                const previousRank = previousRankings.get(data.color);
                const timeString = `${String(data.hours).padStart(2, '0')}:${String(data.minutes).padStart(2, '0')}`;
                
                // Create change indicator
                const changeIndicator = formatTimeChange(data.change);
                
                // Create rank change indicator
                let rankIndicator = '';
                if (previousRank && currentRank !== previousRank) {
                    if (currentRank < previousRank) {
                        rankIndicator = '<span class="rank-up">▲</span>';
                    } else {
                        rankIndicator = '<span class="rank-down">▼</span>';
                    }
                } else {
                    // Add empty span to maintain grid alignment
                    rankIndicator = '<span class="rank-indicator"></span>';
                }

                const summaryItem = document.createElement('div');
                summaryItem.className = 'color-summary-item';
                summaryItem.innerHTML = `
                    <span class="ranking">${currentRank}.</span>
                    <div class="color-indicator" style="background-color: ${data.color}"></div>
                    <span class="label">${data.label}</span>
                    <span class="rank-indicator">${rankIndicator}</span>
                    <div class="time-wrapper">
                        <span class="time-value">${timeString}</span>
                        <span class="time-change">${changeIndicator}</span>
                    </div>
                `;
                summaryContainer.appendChild(summaryItem);
            });
        }

        /*****************
         * Save & Load
         */
         function getTimelineData() {
            return {
                colorPalette: savedColors,
                timeBlocks: blockData,
                goalBlocks: goalBlockData,
                version: "1.1"  
            };
        }

        function saveTimelineToFile() {
            const data = getTimelineData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            const date = new Date().toISOString().split('T')[0];
            a.download = `timeline.json`;
            // a.download = `timeline_${date}.json`;
            a.href = url;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadTimelineFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Load color palette
                    if (data.colorPalette) {
                        savedColors = data.colorPalette;
                        initializeColorPicker();
                    }
                    
                    // Load time blocks
                    if (data.timeBlocks) {
                        loadGridData(data.timeBlocks, 'timeGrid', blockData);
                    }
                    
                    // Load goal blocks
                    if (data.goalBlocks) {
                        loadGridData(data.goalBlocks, 'goalTimeGrid', goalBlockData);
                    }

                    updateTimeSummary();
                } catch (error) {
                    console.error('Error loading timeline:', error);
                    alert('Error loading timeline file');
                }
            };
            
            reader.readAsText(file);
        }

        function loadGridData(data, gridId, dataStore) {
            // First initialize all cells with default values
            for (let hour = 0; hour < 24; hour++) {
                for (let block = 0; block < 6; block++) {
                    const key = `${hour}-${block}`;
                    dataStore[key] = {
                        text: '',
                        color: 'rgb(255, 255, 255)',
                        previousColor: null
                    };
                }
            }

            // Then apply the loaded data
            Object.entries(data).forEach(([key, value]) => {
                const [hour, block] = key.split('-');
                const cell = document.querySelector(`#${gridId} .grid-cell[data-hour="${hour}"][data-block="${block}"]`);
                if (cell) {
                    dataStore[key] = value;
                    cell.textContent = value.text || '';
                    cell.style.backgroundColor = value.color;

                    if (value.previousColor && value.previousColor !== value.color) {
                        cell.classList.add('color-changed');
                        cell.style.setProperty('--previous-color', value.previousColor);
                    }

                    if (rgbToHex(value.color) === '#000000' || value.color === '#000000') {
                        cell.style.color = 'white';
                    } else {
                        cell.style.color = 'black';
                    }
                }
            });
        }

        async function loadJsonUponStart() {
            try {
                const response = await fetch('./examples/timeline.json');
                const data = await response.json();
                
                // Load color palette
                if (data.colorPalette) {
                    savedColors = data.colorPalette;
                    initializeColorPicker();
                }
                
                // Load time blocks
                if (data.timeBlocks) {
                    loadGridData(data.timeBlocks, 'timeGrid', blockData);
                }

                // Load goal blocks
                if (data.goalBlocks) {
                    loadGridData(data.goalBlocks, 'goalTimeGrid', goalBlockData);
                }

                updateTimeSummary();
            } catch (error) {
                console.log('No timeline.json found or error loading file:', error);
            }
        }

        /*****************
         * Utils
         */
        function rgbToHex(rgb) {
            const result = rgb.match(/\d+/g);
            const hex = result.map((value) => {
                const hexValue = parseInt(value, 10).toString(16);
                return hexValue.padStart(2, '0');
            });
            return `#${hex.join('')}`;
        }

        function normalizeColor(color) {
            if (!color) return null;

            if (color.startsWith('#')) {
                return color.toLowerCase();
            }

            // If it's rgb format, convert to hex
            if (color.startsWith('rgb')) {
                const hex = rgbToHex(color);
                return hex ? hex.toLowerCase() : null;
            }
            
            return null;
        }

        function storeCurrentColors(gridId) {
            // Clear the appropriate Map
            const colorStore = gridId === 'timeGrid' ? timeGridStartColors : goalGridStartColors;
            colorStore.clear();

            // Store colors only for the active grid
            document.querySelectorAll(`#${gridId} .grid-cell`).forEach(cell => {
                const key = `${cell.dataset.hour}-${cell.dataset.block}`;
                colorStore.set(key, cell.style.backgroundColor);
            });
        }

        function isDarkColor(color) {
            // Handle both hex and rgb formats
            let r, g, b;
            
            if (color.startsWith('#')) {
                r = parseInt(color.substr(1, 2), 16);
                g = parseInt(color.substr(3, 2), 16);
                b = parseInt(color.substr(5, 2), 16);
            } else {
                const rgb = color.match(/\d+/g);
                if (rgb) {
                    [r, g, b] = rgb.map(Number);
                }
            }
            
            // Calculate relative luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.5;
        }

        function formatTimeChange(minutes) {
            if (minutes === 0) return "";
            
            const sign = minutes > 0 ? "+" : "-";
            const absMinutes = Math.abs(minutes);
            
            if (absMinutes >= 60) {
                const hours = Math.floor(absMinutes / 60);
                const remainingMinutes = absMinutes % 60;
                if (remainingMinutes === 0) {
                    return `${sign}${hours}hr`;
                }
                return `${sign}${hours}hr ${remainingMinutes}m`;
            }
            
            return `${sign}${absMinutes}m`;
        }

        /*****************
         * Event Listener
         */

        // Initialize color picker
        document.getElementById('colorPicker').addEventListener('click', (event) => {
            if (event.target.classList.contains('color-option')) {
                selectedColor = event.target.style.backgroundColor;

                // If we're currently editing a cell, apply the color immediately
                if (currentlyEditingCell) {
                    const gridId = currentlyEditingCell.closest('.grid-container').id;
                    const colorStore = gridId === 'timeGrid' ? timeGridStartColors : goalGridStartColors;
                    const hour = currentlyEditingCell.dataset.hour;
                    const block = currentlyEditingCell.dataset.block;
                    const blockKey = `${hour}-${block}`;
                    
                    // Get the original color
                    const originalColor = colorStore.get(blockKey) || currentlyEditingCell.style.backgroundColor;
                    const newColor = normalizeColor(selectedColor);

                    // Handle color change styling
                    if (originalColor && normalizeColor(originalColor) !== newColor) {
                        currentlyEditingCell.classList.add('color-changed');
                        // currentlyEditingCell.style.borderColor = '#fa9d1b';
                        currentlyEditingCell.style.setProperty('--previous-color', originalColor);
                    } else {
                        currentlyEditingCell.classList.remove('color-changed');
                        currentlyEditingCell.style.borderColor = '';
                        currentlyEditingCell.style.removeProperty('--previous-color');
                    }

                    // Apply the new color
                    currentlyEditingCell.style.backgroundColor = selectedColor;

                    // Update blockData with the new color and existing text
                    const textarea = currentlyEditingCell.querySelector('.editing-textarea');
                    const currentText = textarea ? textarea.value : (blockData[blockKey]?.text || '');
                    
                    // Save to blockData
                    blockData[blockKey] = {
                        text: currentText,
                        color: selectedColor,
                        previousColor: originalColor || null
                    };
                    
                    // Keep the textarea focused and maintain text color
                    if (textarea) {
                        textarea.style.backgroundColor = 'transparent';
                        if (rgbToHex(selectedColor) === '#000000') {
                            textarea.style.color = 'white';
                        } else {
                            textarea.style.color = 'black';
                        }
                        textarea.focus();
                    }

                    updateTimeSummary();
                }
            }
        });

        // Initialize grid when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeGrid('timeGrid');
            initializeGrid('goalTimeGrid');
            initializeColorPicker();  

            loadJsonUponStart();

            addStripedStyle();
            addCurrentTimeRedLineStyle();

            updateElapsedTimeBlocks(); // Initial update

            
            // Save button click handler
            document.getElementById('saveButton').addEventListener('click', saveTimelineToFile);
            
            // Load button click handler
            document.getElementById('loadButton').addEventListener('click', () => {
                document.getElementById('loadInput').click();
            });
            
            // File input change handler
            document.getElementById('loadInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadTimelineFromFile(e.target.files[0]);
                }
            });
            
            // Keyboard shortcut for save (Cmd/Ctrl + S)
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault();
                    saveTimelineToFile();
                }
            });


            // Update every minute
            setInterval(updateElapsedTimeBlocks, 60000);
        });
    </script>
</body>
</html>
